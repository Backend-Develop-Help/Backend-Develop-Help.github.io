---
title: SpringCloud生态+微服务
date: 2024-04-27 16:28:57
author: ethandu
permalink: /pages/771792/
---

视频地址：https://www.bilibili.com/video/BV1LQ4y127n4?spm_id_from=333.999.0.0

# 认识微服务

## 什么是微服务

> 微服务技术栈

![image-20220201152356804](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201152356804.png)

![image-20220201152508315](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201152508315.png)

![image-20220201152547867](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201152547867.png)

![image-20220201152603199](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201152603199.png)

## 微服务架构演变

**单体架构**

单体架构：将业务的所有功能集中在一个项目中开发，打包成一个包部署

优点：

- 架构简单
- 部署成本低

缺点：

- 耦合度高

![image-20220201154102502](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154102502.png)

**分布式架构**

分布式架构：根据业务功能能对系统进行拆分，每个业务模块作为独立项目开发，成为一个服务。

优点：

- 降低服务耦合
- 有利于服务升级拓展

![image-20220201154254059](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154254059.png)

服务治理

![image-20220201154322703](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154322703.png)

微服务

微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：

- 单一职责：微服务拆分粒度更小，每一个服务对应唯一的业务能力，做到单一职责，避免重复业务开发
- 面向服务：微服务对外暴露业务接口
- 自治：团队独立，技术独立，数据独立，部署独立
- 隔离性强：服务调用做好隔离，容错，降级，避免出现级联问题

![image-20220201154620094](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154620094.png)

总结

![image-20220201154730328](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154730328.png)

## 微服务结构对比

微服务结构

![image-20220201154949708](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201154949708.png)

微服务技术对比

![image-20220201155238169](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201155238169.png)

企业需求

![image-20220201155446910](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201155446910.png)

## SpringCloud

SpringCloud

![image-20220201155556172](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201155556172.png)

Springcloud与SpringBoot版本兼容关系

![image-20220201155702877](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201155702877.png)

# 服务拆分及远程调用

服务拆分注意事项

1、不同微服务，不要重复开发相关业务

2、微服务数据独立，不要访问其它微服务的数据库

3、微服务可以将自己的业务暴露为接口，供其它微服务调用

![image-20220201155940261](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201155940261.png)

导入服务拆分Demo

![image-20220201160153361](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201160153361.png)

总结

![image-20220201160443578](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201160443578.png)

## 服务远程调用

订单模块只能查订单，用户模块只能查用户

需求却是订单查询同时把用户信息也查询出来

那么我们不是订单模块直接查用户数据库而是发起请求用户模块获取再对数据进行整合

![image-20220201160748031](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201160748031.png)

> 远程调用方式分析

![image-20220201160915903](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201160915903.png)

问题变成了如何在java代码中发http请求

![image-20220201161020773](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201161020773.png)

![image-20220201214358436](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201214358436.png)

告诉getForObject方法返回的类型和请求的url

## 提供者与消费者

![image-20220201214518906](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201214518906.png)

服务既可以是提供者也可是消费者

总结：

![image-20220201214649835](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201214649835.png)

# EureKa注册中心

**服务调用出现的问题**

服务的部署位置是会变化的，硬编码写着老是变动很麻烦

- 服务消费者改如何获取服务提供者的地址信息？
- 如果有多个服务提供者，消费者该如何选择？
- 消费者如何得知服务提供者的健康状态？

 ![image-20220201214837886](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201214837886.png)

**Eureka的作用**

 ![image-20220201215220036](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215220036.png)

![image-20220201215301897](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215301897.png)

总结：

![image-20220201215323067](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215323067.png)

## 搭建eureka服务

![image-20220201215438171](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215438171.png)

> 搭建EurekaServer服务端步骤如下：

1、创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖

![image-20220201215607995](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215607995.png)

2、编写启动类，添加@EnableEurekaServer注解

3、添加application.yml文件，编写下面的配置

![image-20220201215706428](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201215706428.png)

启动成功这个是注册到Eureka的实例

![image-20220201220129985](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201220129985.png)

> 注册user-service

将user-service服务注册到EurekaServer步骤如下

1、在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖

![image-20220201220457146](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201220457146.png)

2、在application.yml文件，编写下面的配置：(服务名称&eureka的地址信息)

![image-20220201220533394](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201220533394.png)

同理注册order-service

![image-20220201221038091](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221038091.png)

另外，我们可以将user-service多次启动，模拟多实例部署，但是为了避免端口冲突，需要修改端口设置：

![image-20220201221142683](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221142683.png)

![image-20220201221252619](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221252619.png)

![image-20220201221356934](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221356934.png)

可以发现这里多出来了一个服务，我们也可以将它启动，这样就完成了一次启动&注册两个实例

![image-20220201221419437](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221419437.png)

![image-20220201221526766](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221526766.png)

总结：

![image-20220201221753843](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201221753843.png)

> 在order-service完成服务拉取

服务拉取是基于服务名称获取服务列表，然后再对服务列表做负载均衡

1、修改OrderService的代码，修改访问的url路径，用服务名代替ip，端口：

```java
String url="http://userservice/user/"+ order.getUserId();
```

2、在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解：

```java
@Bean
@LoadBalanced
public RestTemplate restTemplate(){
	return new RestTemplate();
}
```

这里调用服务就是采用了默认的轮询方式

# Ribbon负载均衡

负载均衡流程

![image-20220201223158426](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201223158426.png)

上面在RestTemplate上面加的@LoadBalanced注解就是标记了之后发起的请求要被Ribbon拦截和处理了。

我们在代码中打断点调试

![image-20220201223647758](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201223647758.png)

这个就是整个负载均衡的流程

![image-20220201224058180](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201224058180.png)

**负载均衡策略**

Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则：

![image-20220201224324290](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201224324290.png)

![image-20220201224405457](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201224405457.png)

通过定义IRule实现可以修改负载均衡规则，有两种方式：

1、代码方式：在order-service中的OrderApplication类中，定义一个新的IRule

```java
@Bean
public IRule randomRule(){
	return new RandomRule();
}
```

2、配置文件方式：在order-service的application.yml文件中添加新的配置也可以修改规则：

```yaml
userservice:
  ribbon:
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule  # 负载均衡规则
```

## 饥饿加载

发起两次请求，第一次时间很长500多ms，而第二次就只需要27ms就完成了

![image-20220201225221729](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201225221729.png)

![image-20220201225229138](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201225229138.png)

开启后只需要300多就完成第一次加载了还是可以的

![image-20220201225615598](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201225615598.png)

总结：

![image-20220201225710017](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201225710017.png)

# Nacos注册中心

## 认识Nacos

![image-20220201225849120](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201225849120.png)

## **安装Nacos**

 github上下载

>  启动

进入bin目录

然后执行命令既可：

- windows命令：

```bash
startup.cmd -m standalone
```

执行后的效果如图：

![image-20220201231131440](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201231131440.png)

访问8848端口，默认的账号和密码都是“nacos”

![image-20220201231256839](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220201231256839.png)

## **Nacos服务分级存储模型**

![image-20220202154932008](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202154932008.png)

## **服务跨集群调用问题**

![image-20220202155028149](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202155028149.png)

## **服务集群属性**

1、修改application.yml，添加如下内容

```yaml
spring:
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos 服务端地址
      discovery:
        cluster-name: HZ # 配置集群名称也就是机房位置，例如：HZ，杭州
```

2、在Nacos控制台可以看到集群变化：

![image-20220202155727692](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202155727692.png)

总结：

![image-20220202155740840](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202155740840.png)

**服务集群属性**

我们修改user-service配置，达到下面的效果

![image-20220202190556941](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202190556941.png)

1、修改order-service中的application.yml，设置集群为HZ：

```yml
spring:
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos 服务端地址
      discovery:
        cluster-name: HZ # 配置集群名称，也就是机房位置
```

2、然后在order-service中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务：

```yml
userservice:
  ribbon：
    NFLoadBalanceRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则
```

这里的NacosRule是优先采用本地集群，然后在同一地位的集群中随机负载均衡

3、注意将user-service的权重都设置为1



关闭userservice1&userservice2 留了个在上海的userservice3 

![image-20220202191624485](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202191624485.png)

可以看见杭州里面已经没有健康的集群了

![image-20220202191734067](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202191734067.png)

再次请求order-service这个时候日志中产生了跨境请求的警告，这个时候运维看到以后就启动死掉的服务就好了。

![image-20220202191839131](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202191839131.png)

总结：

![image-20220202192037840](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202192037840.png)

## **根据权重负载均衡**

实际部署中会出现这样的场景：

- 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求

Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高

1、在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮

![image-20220202192431738](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202192431738.png)

2、将权重设置为0.1，测试可以发现8081被访问到的频率大大降低

![image-20220202192520692](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202192520692.png)

如果这里将权重设为0那么就不会再被访问了，这样有什么用呢？我们服务需要升级的话以前要在月黑风高的时候用户不用服务的时候升级代码重启我们的服务，这样的问题很大。但是我们这里有集群的话，将集群中一个服务的权重调为0，然后升级，然后再将权重调小一点，放一部分用户来测试，可以的话再将权重调大，这样就不知不觉的时候完成了版本的升级了,平滑升级！

总结：

![image-20220202193201855](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202193201855.png)

## 环境隔离 -namespace

Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，来做最外层隔离

![image-20220202193324509](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202193324509.png)

（服务的划分是根据业务进行的划分，但是我们的环境也是会变化的，所以我们根据环境变化做隔离，namespace就是干这个事的。group是分组，将相关度比较高的服务放进一个组里面）

1.新建一个dev命名空间

![image-20220202193754638](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202193754638.png)

2.然后填写一个新的命名空间信息：

![image-20220202193925310](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202193925310.png)

3.保存后会再控制台看到这个命名空间的id：

![image-20220202194005007](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194005007.png)

4.修改order-service的application.yml，添加namespace：

```yaml
spring:
  datasource:
    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false
    username: root
    password: 123
    driver-class-name: com.mysql.jdbc.Driver
  application:
    name: orderservice
  cloud:
    nacos:
      server-addr: nacos:8848 # nacos服务地址
      discovery:
        cluster-name: HZ
        namespace: 4d6ce343-9e1b-44df-a90f-2cf2b6b3d177 # dev环境
#        ephemeral: false # 是否是临时实例
```

这个时候在服务列表中的public中已经看不到orderservice了，点到旁边的dev，看到了orderservice

![image-20220202194407999](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194407999.png)

发起访问，报错了，因为他们已经隔离了，已经事两个世界的人了！不同namespace下的服务不可见

![image-20220202194516550](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194516550.png)

总结：

![image-20220202194602940](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194602940.png)

## nacos注册中心细节分析

![image-20220202194825901](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194825901.png)

默认情况下所有的实例都是临时实例

![image-20220202194851844](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202194851844.png)

所以我们服务提供者要发起对临时实例心跳检测到nacos。但是要是不是临时实例就是nacos主动询问，而服务提供者不检测。注意，nacos不会把非临时实例从列表中剔除，而仅仅是标记出它不健康了。

![image-20220202195224715](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202195224715.png)

服务消费，eureka做的是pull，而nacos做的事pull+push, 时效性更好，更新效率更高

![image-20220202195317970](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202195317970.png)

### 临时实例和非临时实例

服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置：

```yml
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: false # 设置为非临时实例
```

临时实例宕机时，会从nacos的服务列表中剔除，而非临时实例则不会。

总结：

![image-20220202195851057](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202195851057.png)

# Nacos配置管理

## 统一配置管理

服务要相互调用，要完成相互调用，我们的做法是将服务注册到注册中心，然后消费者就能在注册中心发现，实现服务的获取和负载均衡，完成远程调用。

随着服务多了，配置的集合管理也是问题，同时修改服务及相关服务配置需要重启在生产环境下影响是很大的。要是有一个服务的统一管理+服务的热更新就解决了上面的问题了。

![image-20220202200755476](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202200755476.png)

这里我们的注册中心和配置管理都是nacos

![image-20220202201024878](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202201024878.png)

下面展示怎么让nacos做管理。

![image-20220202201710917](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202201710917.png)

![image-20220202201604424](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202201604424.png)

![image-20220202201625580](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202201625580.png)

我们已经把部分配置放到了nacos服务器上，下面微服务要想办法获取这些配置

原来的配置获取步骤：

![image-20220202202151058](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202202151058.png)

将来我们要将远程的nacos配置文件和本地的application.yml配置文件进行合并再创建spring容器。我们读取nacos配置文件的时候我们要知道两件事情

- 从哪读取
- 读取谁

所以我们要提前知道这些信息，这些配置不能再放在原来的application.yml中了，这里springboot给我们提供了bootstrap.yml优先级比application.yml的优先级要高。

现在的配置的获取步骤：

![image-20220202201933213](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220202201933213.png)

与nacos地址和nacos上的配置文件有关的所有信息都应该放到bootstrap.yml中

1、引入Nacos的配置管理客户端依赖：

```xml
<!-- nacos客户端依赖包 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
```

2、在userservice中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml:

```yaml
spring:
  application:
    name: userservice
  profiles:
    active: dev # 环境
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
```

我们在user-service中将pattern.dateformat这个属性注入到UserController中做测试：

![image-20220211162955709](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211162955709.png)

总结：

![image-20220211163010845](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163010845.png)

## 配置自动刷新

![image-20220211163332384](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163332384.png)

![image-20220211163324754](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163324754.png)

这里我们还缺少东西所以没能实现热更新

Nacos中的配置文件热更新实现方式:

- 方式一：在@Value注入的变量所在类上添加注解@RefreshScope

![image-20220211163408244](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163408244.png)

![image-20220211163549539](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163549539.png)

这里我们出现了大量的日志 这个就是因为我们修改了配置文件导致的

- 方式二：使用@ConfigurationPorperties注解（推荐）

![image-20220211163624660](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211163624660.png)

![image-20220211164007040](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211164007040.png)

将配置注入到对象中然后直接使用(这里的@RefreshScope已注释掉)

总结：

![image-20220211164143826](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211164143826.png)

## 多环境配置共享

微服务启动时会从nacos读取多个配置文件：

![image-20220211164336019](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211164336019.png)

这里我们的userservice是在dev环境所以我们能读到userservice.yaml 和 userservice-dev.yaml

![image-20220211164755564](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211164755564.png)

这里我们将一个服务实例给修改环境为test 这里是一种不用改代码的方法

![image-20220211164857981](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211164857981.png)

![image-20220211165031022](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165031022.png)

现在它读不到userservice-dev.yaml的属性了

- dev环境

![image-20220211165109584](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165109584.png)

![image-20220211165148339](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165148339.png)

- test环境

![image-20220211165123339](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165123339.png)

![image-20220211165206417](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165206417.png)

>  测试本地配置和nacos配置的优先级问题

application.yaml添加

![image-20220211165342027](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165342027.png)

PatternProperties中添加这个属性

![image-20220211165409011](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165409011.png)

在userservice.yaml中添加这个属性

![image-20220211165441451](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165441451.png)

测试发现远端nacos的优先级高

![image-20220211165548463](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165548463.png)

总结：

![image-20220211165559300](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165559300.png)

# Nacos集群搭建

![image-20220211165634428](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165634428.png)

之前我们一直使用的是单点的nacos还不是集群 和企业需求没对接上

## 1.集群结构图

![image-20220211165718131](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165718131.png)

<img src="/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211165725831.png" alt="image-20220211165725831" style="zoom:50%;" />

n台nacos首先要实现数据共享，我们整一个mysql集群，让多台nacos都来在这个集群里面做数据读写这样数据就共享了，而后用户请求进入以后，我们还要让它能分发到不同的nacos节点，这个就是负载均衡。这里使用Nginx来搞负载均衡和反向代理。

![image-20220211170044765](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211170044765.png)

## 2.搭建集群

![image-20220211170132957](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211170132957.png)

这里搞MySQL主从高可用集群搭建还是比较麻烦的

### 2.1.初始化数据库

![image-20220211170217317](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211170217317.png)

```sql
CREATE TABLE `config_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(255) DEFAULT NULL,
  `content` longtext NOT NULL COMMENT 'content',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  `c_desc` varchar(256) DEFAULT NULL,
  `c_use` varchar(64) DEFAULT NULL,
  `effect` varchar(64) DEFAULT NULL,
  `type` varchar(64) DEFAULT NULL,
  `c_schema` text,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_aggr   */
/******************************************/
CREATE TABLE `config_info_aggr` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(255) NOT NULL COMMENT 'group_id',
  `datum_id` varchar(255) NOT NULL COMMENT 'datum_id',
  `content` longtext NOT NULL COMMENT '内容',
  `gmt_modified` datetime NOT NULL COMMENT '修改时间',
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';


/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_beta   */
/******************************************/
CREATE TABLE `config_info_beta` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL COMMENT 'content',
  `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_tag   */
/******************************************/
CREATE TABLE `config_info_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',
  `tag_id` varchar(128) NOT NULL COMMENT 'tag_id',
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL COMMENT 'content',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_tags_relation   */
/******************************************/
CREATE TABLE `config_tags_relation` (
  `id` bigint(20) NOT NULL COMMENT 'id',
  `tag_name` varchar(128) NOT NULL COMMENT 'tag_name',
  `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',
  `nid` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = group_capacity   */
/******************************************/
CREATE TABLE `group_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群',
  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值',
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = his_config_info   */
/******************************************/
CREATE TABLE `his_config_info` (
  `id` bigint(64) unsigned NOT NULL,
  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `data_id` varchar(255) NOT NULL,
  `group_id` varchar(128) NOT NULL,
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL,
  `md5` varchar(32) DEFAULT NULL,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `src_user` text,
  `src_ip` varchar(50) DEFAULT NULL,
  `op_type` char(10) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';


/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = tenant_capacity   */
/******************************************/
CREATE TABLE `tenant_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID',
  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数',
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';


CREATE TABLE `tenant_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `kp` varchar(128) NOT NULL COMMENT 'kp',
  `tenant_id` varchar(128) default '' COMMENT 'tenant_id',
  `tenant_name` varchar(128) default '' COMMENT 'tenant_name',
  `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc',
  `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source',
  `gmt_create` bigint(20) NOT NULL COMMENT '创建时间',
  `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';

CREATE TABLE `users` (
	`username` varchar(50) NOT NULL PRIMARY KEY,
	`password` varchar(500) NOT NULL,
	`enabled` boolean NOT NULL
);

CREATE TABLE `roles` (
	`username` varchar(50) NOT NULL,
	`role` varchar(50) NOT NULL,
	UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE
);

CREATE TABLE `permissions` (
    `role` varchar(50) NOT NULL,
    `resource` varchar(255) NOT NULL,
    `action` varchar(8) NOT NULL,
    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE
);

INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE);

INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN');
```

![image-20220211170958483](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211170958483.png)

总之搭建完成

### 2.2.下载nacos

![image-20220211171050281](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211171050281.png)

### 2.3.配置Nacos

![image-20220211171201438](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211171201438.png)

![image-20220211171207947](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211171207947.png)

然后添加内容：

```bash
127.0.0.1:8845
127.0.0.1:8846
127.0.0.1:8847
```



然后修改application.properties文件，添加数据库配置

```properties
spring.datasource.platform=mysql

db.num=1

db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
db.user.0=root
db.password.0=123
```

首先路径不要有中文，其次这里我的还需要将ip指定成127.0.0.1否则每次都会走默认ip

### 2.4.启动

将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3

![image-20210409213335538](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20210409213335538.png) 

然后分别修改三个文件夹中的application.properties，

nacos1:

```properties
server.port=8845
```

nacos2:

```properties
server.port=8846
```

nacos3:

```properties
server.port=8847
```



然后分别启动三个nacos节点：

```
startup.cmd
```

![image-20220211181320050](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211181320050.png)

### 2.5.nginx反向代理

找到课前资料提供的nginx安装包： 

![image-20210410103253355](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20210410103253355.png) 

解压到任意非中文目录下：

![image-20210410103322874](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20210410103322874.png) 

修改conf/nginx.conf文件，配置如下：

```nginx
upstream nacos-cluster {
    server 127.0.0.1:8845;
	server 127.0.0.1:8846;
	server 127.0.0.1:8847;
}

server {
    listen       80;
    server_name  localhost;

    location /nacos {
        proxy_pass http://nacos-cluster;
    }
}
```



而后在浏览器访问：http://localhost/nacos即可。

![image-20220211201208389](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211201208389.png)

这里的访问会在这三个nacos里面做反向代理



代码中application.yml文件配置如下：

```yaml
spring:
  cloud:
    nacos:
      server-addr: localhost:80 # Nacos地址
```

### 2.6.优化

- 实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.

- Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离

总结：

![image-20220211201439881](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211201439881.png)

# http客户端Feigin

RestTemplate方式调用存在的问题

![image-20220211211803654](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211211803654.png)

## Feign的介绍

![image-20220211211823097](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211211823097.png)

定义和使用Feign客户端

![image-20220211211918200](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211211918200.png)

这个里面的注解甚至用的是springmvc里面的注解

![image-20220211211927764](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211211927764.png)

Feign是声明式http客户端 上面这段代码将http请求所需要的所有东西feign通过声明客户端的方式弄好了

Feign非常强大 里面已经包含了负载均衡功能了(核心依赖里面已经集成了Ribbon)

![image-20220211212853444](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211212853444.png)

总结：

![image-20220211212936492](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211212936492.png)

## 自定义Feign的配置

![image-20220211213038641](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211213038641.png)

失败重试：可能是服务宕机或网络原因 Ribbon就不会等了 它会做重试去试试另一个服务能不能访问

配置Feign日志的两种方式:

- 方式一：配置文件方式

![image-20220211213350412](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211213350412.png)

![image-20220211213617996](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211213617996.png)

- 配置Feign日志的方式二：java代码方式，需要先声明一个Bean：

![image-20220211213712935](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211213712935.png)

总结：

![image-20220211213900199](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211213900199.png)

## Feign的性能优化

![](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211214110235.png)

### 连接池配置

![image-20220211214940169](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211214940169.png)

真实情况需要根据压测结果进行调节

总结：

![image-20220211215224024](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211215224024.png)

## Feign的最佳实践（踩坑后的比较好的实现方式）

- 方式一（继承）：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准

原来：

![image-20220211215418102](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211215418102.png)

这里的userservice的接口和orderservice里面的Feign客户端写的接口实际上是一样的

![image-20220211215543869](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211215543869.png)

现在：（给两个地方定义统一的标准约束了两边怎么去做）

![image-20220211215646406](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211215646406.png)

==但是官方并不推荐去共享接口在服务端和客户端之间，因为会造成紧耦合 两个服务在API上都一样了 并且这里在springmvc中是不会生效的 因为方法参数（@PathVarible）是继承不下来的==

![image-20220211215843271](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211215843271.png)

![image-20220211220015249](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211220015249.png)

- 方式二（抽取）：将FeignClient抽取为独立模块，并且把接口有关的POJO，默认的Feign配置都放到这个模块中，提供给所有消费者使用

思考一个问题 随着服务的增多我们这个userclient也是（要用的话）每次都写这样也是重复开发了 

![image-20220211220124587](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211220124587.png)

这里我们用一个feign的api 在这个项目中把这个写好 把实体类也写好 配置也写好 ==服务要用直接引依赖就好了依赖有了就直接调就好了== 这个是一个统一的抽取的方式

![image-20220211220419702](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211220419702.png)

但是它也有一个问题例如orderservice里面我只需要用里面的其中一个方法 但是我们把所有的都引进来了

所以没有完美的解决方案



总结：

![image-20220211220709974](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211220709974.png)

## 抽取FeignClient

![image-20220211221041511](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221041511.png)

引入依赖

![image-20220211221119530](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221119530.png)

将UserClient	DefaultFeignConfiguration	User实体类都放进去

将OrderService中先前里面有的User	UserClient	DefaultFeignConfiguration全部删掉（这里之前的依赖找不到了所以会报错）

![image-20220211221237816](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221237816.png)

在orderservice中导入feign-api包将依赖替换成feign-api里面的东西

![image-20220211221351873](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221351873.png)

现在除了这个开启客户端已经在OrderService里面没有关于Feign的东西了

![image-20220211221449705](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221449705.png)

但是这里启动报错了 说这个UserClient无法被注入

如果熟悉Spring应该知道编译没有报错证明类有 但是无法注入说明没有创建对象 也就是在spring容器中找不到它所以注入失败 UserClient这个接口之所以以前有对象是因为

![image-20220211221744004](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211221744004.png)

这个接口以前有这个注解 spring扫描到这个注解就会给这个接口创建对象 现在没有扫描到包了 我们的orderservice默认的扫描包是启动类在的包 和feign-api里面的UserClient显然不在一个包 扫不到的 所以spring容器中没有这个bean这就无法注入了 （把orderservice扫描包改掉是显然不合适的）

> 解决方案

![image-20220211222204827](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211222204827.png)

(更推荐第二种方案 只需要扫描需要的client 只加载需要的客户端)

总结：

![image-20220211222420062](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211222420062.png)

# 统一网关 Gateway

## 为什么需要网关

服务内部有相互访问的话Feign进行调用 但是外部的请求就没有安全措施了 不是所有业务都是对外公开的 我们得对用户的身份进行验证 否则拦截

![image-20220211222707258](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211222707258.png)

这里网关就出现了并且带着这些功能来了

![image-20220211222943540](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211222943540.png)

网关技术实现(目前来说都会使用gateway来进行网关)

![image-20220211223038457](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211223038457.png)

## 搭建网关服务

搭建网关服务的步骤：

![image-20220211223143755](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220211223143755.png)

网关自己也是服务 需要被nacos发现

2.编写路由配置及nacos地址

![image-20220213102823916](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213102823916.png)

lb:loadBalance缩写

当前含义： 我要把请求路由到用户服务（userservice）

需要一个路由规则（和nginx很像）predicates:(判断请求是否符合路由规则)

![image-20220213103047250](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103047250.png)

![image-20220213103205052](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103205052.png)

用nginx请求会到服务上，要在服务做鉴权，网关可以先鉴权拦截，不会给服务造成太大压力

 总结：

![image-20220213103630598](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103630598.png)

## 路由断言工厂Route Predicate Factory

![image-20220213103724932](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103724932.png)

![image-20220213103813127](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103813127.png)

![image-20220213103821591](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213103821591.png)

![image-20220213104011647](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213104011647.png)

这里的路由规则是要求在2031年之后才可以访问, 访问的话就会报404

使用Before的话就可以访问到了

这个路由工厂的规则按照需求使用不用强记

![image-20220213104231303](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213104231303.png)

## 路由过滤器 GatewayFilter

![image-20220213104412516](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213104412516.png)

这里响应结果的返回过程也是可以被网关做操作再返回给用户的，例如：把响应头拿出来，把响应体弄一弄之类

![image-20220213104557062](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213104557062.png)

（要点：根据名字来了解过滤器工厂的功能）

![image-20220213104730096](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213104730096.png)

验证 在这个方法中添加一个参数 加上这个注解`@RequestHeader` 这样spring就能帮助我们获得这个请求头的这个参数，加required可以应对没有传过来的情况

![](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105007102.png)

我们如果要在所有的微服务都实现这个功能(配置在某个路由下只对那个服务有效 配置在default过滤器下 对所有的服务有效)

![image-20220213105148878](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105148878.png)

总结：

![image-20220213105316392](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105316392.png)

## 全局过滤器 GlobalFilter

![image-20220213105455040](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105455040.png)

![image-20220213105557044](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105557044.png)

(未登录的状态码是401 返回状态码为了用户体验)

![image-20220213105941410](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213105941410.png)

实现这个过滤器在上面加两个注解

![image-20220213110130847](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110130847.png)

@Order(-1)将过滤器的位置或者说执行顺序确定

或者不用这个注解 实现Ordered接口 继承它的getOrder()方法 一样可以实现过滤器执行顺序的指定

![image-20220213110219399](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110219399.png)

测试：

![image-20220213110345992](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110345992.png)

![image-20220213110405566](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110405566.png)

当然实际开发的登录拦截不会说逻辑这么简单

![image-20220213110417191](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110417191.png)

总结：

![image-20220213110441418](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110441418.png)

## 过滤器执行顺序

![image-20220213110756047](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110756047.png)

![image-20220213110952750](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110952750.png)

![image-20220213110915743](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213110915743.png)

总结：

![image-20220213111026815](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111026815.png)

## 跨域问题处理

所有的请求都是先经过网关再到微服务 所以跨域请求不是在每个服务处理 只需要在网关里面处理就好了

![image-20220213111337534](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111337534.png)

CORS： 浏览器问下服务器能不能走这个跨域请求

![image-20220213111419665](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111419665.png)

我们的ajax采用的是CORS方案 这个方案有一次询问 这个询问也是会被网关拦截的 加上 `add-to-simple-url-handler-mapping: true`可以解决询问被拦截的问题

加上有效期`maxAge`的设置可以让询问不要每次都执行给服务器增加压力

测试：

![image-20220213111751571](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111751571.png)

![image-20220213111806120](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111806120.png)

将网关的跨域配置加上以后重启服务

![image-20220213111907615](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111907615.png)

总结：

![image-20220213111934502](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213111934502.png)

我们现在已经学了微服务最常用的组件了

# Docker

![image-20220213114201591](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114201591.png)

![image-20220213114229582](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114229582.png)

![image-20220213114309650](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114309650.png)

![image-20220213114402754](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114402754.png)

![image-20220213114446955](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114446955.png)

![image-20220213114537910](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114537910.png)

![image-20220213114613763](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114613763.png)

总结：

![image-20220213114644298](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213114644298.png)

## Docker与虚拟机

Docker把应用所需要的依赖，函数库甚至操作系统函数库都

一并打包，当应用运行时可以直接调用本地的函数库和内核（也就是linux操作系统内核）交互，那样就不用管是什么系统应用了，这样就形成了跨系统的运行了。



虚拟机：使用Hypervisor技术模拟出一个计算机的各种硬件，在模拟的计算机上安装各种操作系统，然后安装各种应用。当应用执行时，它会以为自己在一台真的电脑上，它会先调用内置的操作系统，然后操作系统和Hypervisor进行交互，然后再把信息传递给外部的操作系统，然后外部操作系统在去操作真实硬件。这样子性能和docker比是会差一点的（docker是直接调用操作系统内核的）。

![image-20220213115421990](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213115421990.png)

总结：

![image-20220213115451580](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213115451580.png)

## 镜像和容器

![image-20220213115653421](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213115653421.png)

## Docker和DockerHub

![image-20220213115729914](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213115729914.png)

## Docker架构

![image-20220213115907054](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213115907054.png)

总结：

![image-20220213120019190](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120019190.png)

## Docker镜像操作练习

![image-20220213120058536](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120058536.png)

![image-20220213120135474](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120135474.png)

![image-20220213120158110](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120158110.png)

![image-20220213120209139](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120209139.png)

将镜像保存: docker save -o redis.tar redis:latest(-o 代表输出)

![image-20220213120333856](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120333856.png)

![image-20220213120341596](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120341596.png)

希望将这个镜像加载回来 先删除这个镜像

![image-20220213120426202](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120426202.png)

![image-20220213120432360](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120432360.png)

用tar包加载回来

![image-20220213120448258](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120448258.png)

![image-20220213120455337](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120455337.png)

又回来了

## Docker基本操作-容器

![image-20220213120541127](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120541127.png)

![image-20220213120548361](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120548361.png)

![image-20220213120636139](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120636139.png)

![image-20220213120730653](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120730653.png)

![image-20220213120738410](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120738410.png)

![image-20220213120802160](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120802160.png)

![image-20220213120811647](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120811647.png)

![image-20220213120818659](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120818659.png)

![image-20220213120826912](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120826912.png)

一步到位  docker exec -it mr redis-cli (进入一个容器执行一个命令)

![image-20220213120857382](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213120857382.png)

## 数据卷

![image-20220213121141562](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121141562.png)



我们利用docker创建了一个新的数据卷html那么docker一定会在这个指定的目录下创建一个真实目录 然后每一个数据卷都和真实目录进行映射

![image-20220213121347514](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121347514.png)

容器在创建的时候可以使用数据卷

这里通过Volumes可以实现容器中的数据和宿主机中真实位置的文件双向绑定

![image-20220213121456541](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121456541.png)

![image-20220213121607199](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121607199.png)

假如容器删了 但是只要挂载的数据卷没删以后的新容器也挂载在这个数据卷上的话以前的数据就还是能用的

### 操作数据卷

![image-20220213121743472](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121743472.png)

案例：

![image-20220213121759156](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121759156.png)

![image-20220213121829753](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121829753.png)

![image-20220213121843048](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121843048.png)

![image-20220213121854704](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121854704.png)

特别要注意的是Mountpoint(挂载点)

![image-20220213121915345](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213121915345.png)

删除数据卷

![image-20220213122012379](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122012379.png)

![image-20220213122045828](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122045828.png)

![image-20220213122053966](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122053966.png)

指定删除

![image-20220213122105760](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122105760.png)

![image-20220213122116324](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122116324.png)

![image-20220213122142022](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122142022.png)

总结:

![image-20220213122205247](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213122205247.png)

### 挂载数据卷

![image-20220213134918142](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213134918142.png)

![image-20220213134949401](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213134949401.png)

![image-20220213135131464](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135131464.png)

![image-20220213135218175](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135218175.png)

![image-20220213135226031](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135226031.png)

这个时候我们想知道它挂载的目录在哪里

![image-20220213135302202](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135302202.png)

![image-20220213135312782](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135312782.png)

这说明已经挂载在宿主机的这个位置上了

修改index.html

![image-20220213135441075](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135441075.png)

![image-20220213135457608](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135457608.png)

这样子的话我们就可以在高级编辑器里面修改了

![image-20220213135549674](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135549674.png)

![image-20220213135608773](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135608773.png)

![image-20220213135616441](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135616441.png)

这说明启动指定数据卷的时候 不存在数据卷的时候docker也会自动创建

![image-20220213135707173](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135707173.png)

总结：

![image-20220213135717014](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135717014.png)

### 宿主机目录直接挂载到容器

![image-20220213135844322](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213135844322.png)

![image-20220213140029600](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140029600.png)

![image-20220213140043923](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140043923.png)

mkdir(-p多级创建目录)

![image-20220213140115932](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140115932.png)

![image-20220213140200830](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140200830.png)

到这所有的准备工作都完成了

到官网上查看一下运行容器的命令（-e是环境变量）

![image-20220213140240631](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140240631.png)

这里官网的还差了端口和数据卷的挂载我们对它进行改造

-p(容器内端口：宿主机端口) -d（后台运行）--name(容器名指定)

![image-20220213140534845](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140534845.png)

这里我们查看官方文档再继续编辑

![image-20220213140715095](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140715095.png)

![image-20220213140800451](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140800451.png)

![image-20220213140810981](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140810981.png)

![image-20220213140825629](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140825629.png)

![image-20220213140902354](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140902354.png)

![image-20220213140916598](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213140916598.png)

>  数据卷挂载方式对比

宿主机目录挂载优势我自己创建的所以定位很方便 但是需要自己管理

容器内目录挂载优势是自动化 但是不容易定位



总结：

![image-20220213141122780](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213141122780.png)

## Dockerfile自定义镜像

我们以后写的微服务代码需要自己制作镜像

### 镜像结构

- 镜像是将应用程序及其需要的系统函数库 环境 配置 依赖打包而成。

我们拿mysql镜像举例

![image-20220213141603014](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213141603014.png)

总结：

![image-20220213141659546](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213141659546.png)

## 自定义镜像

### 什么是Dockerfile

![image-20220213141757118](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213141757118.png)

![image-20220213141952933](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213141952933.png)

![image-20220213142102653](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213142102653.png)

将课前资料上传到虚拟机里面

![image-20220213143200555](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143200555.png)

这里我们使用dockerfile创建这个镜像 

-t(意思是tag) 后面的空格+"."意思是告诉Dockerfile在哪里 因为这里的Dockerfile和当前目录是同级的所以我们直接用一个"."来告知位置

![image-20220213143325879](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143325879.png)

这里它就是在逐步的执行我们的指令了

![image-20220213143553014](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143553014.png)

![image-20220213143644601](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143644601.png)

![image-20220213143804475](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143804475.png)

到这里就完成了

但是我们发现上面这么多的部分实际上都是在安装jdk 构建我们自己的项目的步骤就下面一点点 那么我们是不是可以在一个用上面步骤创建的镜像的基础上使用dockerfile创建自己的镜像呢

![image-20220213143935985](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213143935985.png)

![image-20220213144123240](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213144123240.png)

这里我们基于java:8-alpine来写dockerfile 这下就非常简单了

![image-20220213144155771](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213144155771.png)

![image-20220213144541643](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213144541643.png)

![image-20220213144725061](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213144725061.png)

总结：

![image-20220213144634794](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213144634794.png)

# DockerCompose

实际生产环境下微服务成百上千个我们一个个构建实在太慢了 我们必须有一个集群构建的方式这里就是DockerCompose了

## 什么是DockerCompose

![image-20220213145024675](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145024675.png)

实际上就是把docker run里面的参数都转换成compose里面的语法来实现了

![image-20220213145201845](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145201845.png)

![image-20220213145327539](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145327539.png)

![image-20220213145346691](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145346691.png)

## 安装DockerCompose

将docker-compose文件上传到/usr/local/bin/目录

![image-20220213145633892](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145633892.png)

### 修改文件权限

![image-20220213145714117](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145714117.png)

![image-20220213145830648](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145830648.png)

上面没有x的文件是没有执行权的 现在的docker-compose拥有了执行权

Final Shell里面更加直观直接变绿了

![image-20220213145928584](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213145928584.png)

### Base自动补全命令

```sh
# 补全命令
curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose
```

如果这里出现错误，需要修改自己的hosts文件：

```sh
echo "199.232.68.133 raw.githubusercontent.com" >> /etc/hosts
```

![image-20220213150145483](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213150145483.png)

这里用老师的方案不行 删掉之前在/etc/hosts里面的修改然后使用官网的方法

https://docs.docker.com/compose/completion/

```sh
# 使用官网的命令安装
sudo curl \
    -L https://raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/bash/docker-compose \
    -o /etc/bash_completion.d/docker-compose
```

![image-20220213150850316](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213150850316.png)

总结:

![image-20220213150437585](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213150437585.png)

## DockerCompose-部署微服务

![image-20220213151238402](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213151238402.png)

![image-20220213151326801](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213151326801.png)

但是我们这里的jar包都没有 需要我们把这些jar放到这里的同级目录里面



![image-20220213151524992](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213151524992.png)

我们希望的是把数据卷给挂载到提前写好的/mysql/data和/mysql/conf下的

$PWD的写法意思是在当前目录下开始找（这样防止切换环境文件就找不到了）

再后面这些由于它们的dockerfile都在对应的目录里面所以build就这样告知就好了

![image-20220213152216126](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213152216126.png)

![image-20220213220438571](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213220438571.png)

使用dockercompose部署时我们直接使用服务名就可以访问了（将localhost之类的服务改名成服务名）



打包最后的项目名称

![image-20220213220616174](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213220616174.png)

![image-20220213220755630](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213220755630.png)

然后将app.jar全部导到对应的子目录中

![image-20220213220902489](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213220902489.png)

![image-20220213220924449](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213220924449.png)

![image-20220213221024290](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213221024290.png)



## Docker镜像仓库

管理镜像的地方

### 常见镜像仓库服务

![image-20220213221225676](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213221225676.png)

### 私有镜像仓库

搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。

官网地址：https://hub.docker.com/_/registry



#### 简化版镜像仓库

Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。

搭建方式比较简单，命令如下：

```sh
docker run -d \
    --restart=always \
    --name registry	\
    -p 5000:5000 \
    -v registry-data:/var/lib/registry \
    registry
```



命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。

访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像



#### 带有图形化界面版本

使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：

```yaml
version: '3.0'
services:
  registry:
    image: registry
    volumes:
      - ./registry-data:/var/lib/registry
  ui:
    image: joxit/docker-registry-ui:static
    ports:
      - 8080:80
    environment:
      - REGISTRY_TITLE=传智教育私有仓库
      - REGISTRY_URL=http://registry:5000
    depends_on:
      - registry
```



#### 配置Docker信任地址

我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：

```sh
# 打开要修改的文件
vi /etc/docker/daemon.json
# 添加内容：
"insecure-registries":["http://192.168.150.101:8080"]# 改成自己的ip
# 重加载
systemctl daemon-reload
# 重启docker
systemctl restart docker
```

![image-20220213223320108](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223320108.png)

![image-20220213223329304](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223329304.png)

#### 在私有镜像仓库推送或拉取镜像

![image-20220213223341639](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223341639.png)

要想推送私有镜像一定要重命名

![image-20220213223724975](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223724975.png)

![image-20220213223740942](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223740942.png)

![image-20220213223917570](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213223917570.png)

总结：

![image-20220213224012237](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213224012237.png)

# 初识MQ

## 同步通讯和异步通讯

![image-20220213224214526](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213224214526.png)

### 同步调用的问题

![image-20220213224605926](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213224605926.png)

![image-20220213224725874](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213224725874.png)

每加一次需求代码都需要修改

再加上是同步调用 用户必须等待订单服务完成才能执行仓储服务执行完才能执行短信服务 总耗时500ms很恐怖 性能太差

在整个过程中有很多资源的浪费 要是卡住在仓储服务支付服务就渐渐被耗尽了

![image-20220213224950164](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213224950164.png)

![image-20220213225025676](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225025676.png)

总结：

![image-20220213225114871](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225114871.png)

### 异步调用方案

![image-20220213225252153](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225252153.png)

优势一：服务解耦

现在加需求就不需要再修改支付服务里面的代码 例如添加了优惠卷服务 因为我们呢现在支付服务不负责调用服务了 而是发消息 那么后面添加服务就只需要订阅事件就好了

解除服务的话我们也就取消订阅就ok了

优势二：性能提升，吞吐量提高

![image-20220213225623644](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225623644.png)

优势三：服务没有强依赖，不担心级联失败问题

![image-20220213225654961](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225654961.png)

优势四：流量消峰

![image-20220213225826285](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225826285.png)

总结：

![image-20220213225941732](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213225941732.png)

### 我的理解

传统的微服务调用用的是openFeign之类的通信手段，这个实际上在不对代码做处理的时候是同步的。

但是我们的消息队列是可以声明“监听器”，监听到消息队列中有消息就执行业务逻辑的。这个实际上就是一种响应式的架构。不需要我们主动的去通信等待另一个微服务执行完毕，而是发个消息给消息队列，而微服务自己监听到消息就执行逻辑。

这种响应式的架构实际上就是异步的，非阻塞的。快速的。



## 什么是MQ

![image-20220213230503194](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213230503194.png)

## RabbitMQ概述

![image-20220213230651293](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213230651293.png)

![image-20220213231023725](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213231023725.png)

一般来说我创建一个用户他有自己的虚拟主机 然后我再创建一个用户他还是有一个虚拟主机 虚拟主机之间是相互隔离的互不干扰

总结：

![image-20220213231145170](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213231145170.png)

## 常见消息模型

![image-20220213231317415](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213231317415.png)

![image-20220213231355226](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220213231355226.png)

![image-20220214200232288](/img/ethandu/微服务/SpringCloud+微服务.assets/image-20220214200232288.png)

要向mq发送消息必须要和它先建立连接 用到连接工厂

![image-20220310215759080](黑马微服务课程笔记.assets/image-20220310215759080.png)

这边有itcast的虚拟主机的访问权

![image-20220310215818996](黑马微服务课程笔记.assets/image-20220310215818996.png)

创建通道

![image-20220310215932324](黑马微服务课程笔记.assets/image-20220310215932324.png)

![image-20220310215949632](黑马微服务课程笔记.assets/image-20220310215949632.png)

有了通道可以向队列里面发送消息了

那么我们需要的是创建一个队列

![image-20220310220104132](黑马微服务课程笔记.assets/image-20220310220104132.png)

![image-20220310220124657](黑马微服务课程笔记.assets/image-20220310220124657.png)

生产者向队列里面发送消息

![image-20220310220114996](黑马微服务课程笔记.assets/image-20220310220114996.png)

![image-20220310220210879](黑马微服务课程笔记.assets/image-20220310220210879.png)

![image-20220310220230202](黑马微服务课程笔记.assets/image-20220310220230202.png)

这个时候我们的发送者已经任务结束了 连接都断开了， 这样就解除耦合了 变成异步了

![image-20220310220356907](黑马微服务课程笔记.assets/image-20220310220356907.png)

接收消息的是Consumer

同样的是先创建连接

![image-20220310220828540](黑马微服务课程笔记.assets/image-20220310220828540.png)

创建通道 创建队列(这里创建的原因是因为 我们的生产者和消费者启动的顺序是不确定的 万一消费者先启动找不到队列 )

![image-20220310220910809](黑马微服务课程笔记.assets/image-20220310220910809.png)

然后就是接收消息了 里面的匿名内部类的对象的方法是我们的处理操作(handleDelivery) 我们把这个行为给挂在了队列上 一旦有消息它就会进行操作处理  最后一个参数byte[] body就是消息体

![image-20220310221130096](黑马微服务课程笔记.assets/image-20220310221130096.png)

这是一个异步的机制，这行代码（接收到消息）在等待接收消息后面打印 该处理消息处理消息 我还是继续去执行我后面的业务去了

![image-20220310221608148](黑马微服务课程笔记.assets/image-20220310221608148.png)

总结

![image-20220310221730227](黑马微服务课程笔记.assets/image-20220310221730227.png)

## SpringAMQP(大大简化api)

大大的简化我们的api

![image-20220310221844454](黑马微服务课程笔记.assets/image-20220310221844454.png)

**AMQP: 是消息队列的规范**

SpringAMQP：是Spring对AMQP的实现（就像是redis里面spring提供的模板）

官网讲的特征：

![image-20220310222038096](黑马微服务课程笔记.assets/image-20220310222038096.png)

SpringAMQP实现HelloWorld种的基础消息队列功能

流程如下:

![image-20220310222214794](黑马微服务课程笔记.assets/image-20220310222214794.png)

![image-20220310222518608](黑马微服务课程笔记.assets/image-20220310222518608.png)

![image-20220310222543355](黑马微服务课程笔记.assets/image-20220310222543355.png)

总结

![image-20220310222928585](黑马微服务课程笔记.assets/image-20220310222928585.png)

子啊Consumer中编写消费逻辑，监听simple.queue 接收的是String类型的消息 将来都是Spring帮助我们完成任务 十分的优雅

![image-20220310223013568](黑马微服务课程笔记.assets/image-20220310223013568.png)

总结

![image-20220310223424112](黑马微服务课程笔记.assets/image-20220310223424112.png)

## WorkQueue 工作队列(模型)

![image-20220310223600783](黑马微服务课程笔记.assets/image-20220310223600783.png)

队列后面跟了两个消费者，消息将来给谁？

rabbitmq中消息是阅后即焚

消息一旦让消费者1消费了消费者2就肯定是拿不到了。

两个消费者实际上是合作关系，共同处理。

假设只有一个消费者，它的处理速度是：40条消息/s，但是发布者却每s发布了50条。这个就暂时是搞不定了，每s有10条消息多出来没人处理，就只能堆积在队列当中，队列在内存中是有存储上限的，这样下去一定会把队列给堆满，这样再有消息就进不去了。如果进不去，消息就会被丢弃，这样就出问题了。两个消费者，每s都处理40条消息的话之前的情况就是可以轻松应对了。



所以WorkQueue实际上就还是普通的消息队列，只是挂了两个消费者。可以提高消息处理速度，避免队列消息堆积。

![image-20220512104256528](黑马微服务课程笔记.assets/image-20220512104256528.png)

![image-20220512105653155](黑马微服务课程笔记.assets/image-20220512105653155.png)

消费者1消费的快，消费者2消费的慢，就少消费一点，毕竟能者多劳，但是我们现在是平均分布。这个并不是我们想要的。

这个就是我们的消息预取机制。什么叫做消息预取？当我们大量的消息到达队列的时候队列会将消息进行投递，consumer1和consumer2的通道（channel）会把消息先拿过来，这个叫做消息预取。管他能不能处理，先拿过来再说，

![image-20220512105952141](黑马微服务课程笔记.assets/image-20220512105952141.png)

这下就两边各自处理了50条消息了，于是两个人就平均分配了所有的消息，每个人25条，但是消费者1处理的快，很快搞定了，消费者2处理的慢，就花了很长时间才搞定

消费预取限制：

![image-20220512110154593](黑马微服务课程笔记.assets/image-20220512110154593.png)

我们这里就是预取1条消息，消费完成以后再去拿，不至于一下预取一大堆结果处理不完。

![image-20220512110719221](黑马微服务课程笔记.assets/image-20220512110719221.png)

这个就起到了一个能者多劳的效果了。

最后我们做一个总结：

![image-20220512110408528](黑马微服务课程笔记.assets/image-20220512110408528.png)

这个模式可以提高整个队列的速度。

这里我们发现在代码中创建队列或者交换机之类的也是非常简单(包括这些绑定交换机到队列之类的操作，都是可以在一个config类中解决的，只要将amqp包中的对象给注册到SpringIOC容器中就好了)

```java

@Configuration
public class FanoutConfig {
    // itcast.fanout
    @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange("itcast.fanout");
    }

    // fanout.queue1
    @Bean
    public Queue fanoutQueue1(){
        return new Queue("fanout.queue1");
    }

    // 绑定队列1到交换机
    @Bean
    public Binding fanoutBinding1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
        return BindingBuilder
                .bind(fanoutQueue1)
                .to(fanoutExchange);
    }

    // fanout.queue2
    @Bean
    public Queue fanoutQueue2(){
        return new Queue("fanout.queue2");
    }

    // 绑定队列2到交换机
    @Bean
    public Binding fanoutBinding2(Queue fanoutQueue2, FanoutExchange fanoutExchange){
        return BindingBuilder
                .bind(fanoutQueue2)
                .to(fanoutExchange);
    }

    @Bean
    public Queue objectQueue(){
        return new Queue("object.queue");
    }

    @Bean
    public Queue simpleQueue(){
        return new Queue("simple.queue");
    }

}
```

![image-20220512111013751](黑马微服务课程笔记.assets/image-20220512111013751.png)



## 发布订阅模型介绍

刚才我们的消息都是阅后即焚的（一旦消费完就会从队列中删除），这个就无法达到给多个消费者消费了。

这个就无法满足我们课程开始时提出的需求：当用户支付完成了，你得去通知订单服务，仓储服务，短信服务。让这些服务各自去完成自己的业务。

现在的消息要被3个服务都收到。

那么就需要用到发布订阅模型了。实现方式实际上就是加上了一个交换机（exchange）。这个模型和计算机网络实际上是一样的。

![image-20220512111653755](黑马微服务课程笔记.assets/image-20220512111653755.png)

这个模型我们不关心消费者怎么绑定。我们关心的是消息如何从发布者到达队列。

消息发布到交换机，然后交换机将消息转发到队列当中。消息发布者不需要知道投递到队列的细节，这些都是交换机决定的，交换机转发消息给多个队列，这个就实现了我们的一份消息多个消费者消费的需求了！

到底交换机是发送给一个还是多个呢？

![image-20220512112410933](黑马微服务课程笔记.assets/image-20220512112410933.png)

exchange只负责转发，不管消息是否丢失，只有队列是存消息的。

### 发布订阅-Fanout Exchange

![image-20220512112559133](黑马微服务课程笔记.assets/image-20220512112559133.png)

![image-20220512112629997](黑马微服务课程笔记.assets/image-20220512112629997.png)

SpringAMQP提供了声明交换机，队列，绑定关系的API，例如：

![image-20220512112642809](黑马微服务课程笔记.assets/image-20220512112642809.png)



![image-20220512112737269](黑马微服务课程笔记.assets/image-20220512112737269.png)

连绑定都是需要声明的，利用BindingBuilder这个提供给我们的工厂。（绑定它（队列）到它（交换机））

![image-20220512112936808](黑马微服务课程笔记.assets/image-20220512112936808.png)

这里我们是通过声明Bean的方式去写的。

将来它读取到这些Bean以后就会帮我们，向rabbitmq去声明队列，交换机，绑定关系。全部都由Spring帮我们去做。

![image-20220512113155611](黑马微服务课程笔记.assets/image-20220512113155611.png)

![image-20220512113202359](黑马微服务课程笔记.assets/image-20220512113202359.png)

交换机点到这个里面来，看到这个bindings

![image-20220512113227937](黑马微服务课程笔记.assets/image-20220512113227937.png)

![image-20220512113320885](黑马微服务课程笔记.assets/image-20220512113320885.png)

队列就已经绑定上了。

![image-20220512113602086](黑马微服务课程笔记.assets/image-20220512113602086.png)

这里以前是发送到队列，现在是发送到交换机。

![image-20220512113607932](黑马微服务课程笔记.assets/image-20220512113607932.png)

然后发送消息，两个队列都收到了，这个就是fanout exchange

![image-20220512113506269](黑马微服务课程笔记.assets/image-20220512113506269.png)

总结：

![image-20220512113649167](黑马微服务课程笔记.assets/image-20220512113649167.png)

### 发布订阅-DirectExchange

![image-20220512113724535](黑马微服务课程笔记.assets/image-20220512113724535.png)

会将消息根据路由规则路由到指定的Queue

这个也就被称为路由模式（routes）

![image-20220512113836463](黑马微服务课程笔记.assets/image-20220512113836463.png)

我们现在两个队列都有自己的bindingkey了，将来发布者发送消息的时候也要指定一个RoutingKey

这个时候Exchange将消息路由到队列的时候要比对bindingkey了。

![image-20220512114059766](黑马微服务课程笔记.assets/image-20220512114059766.png)

这里要是我们发送的消息是bindingkey是red的话就和我们之前的fanoutexchange一样了，就都是广播了。

所以我们可以用DirectExchange来模拟FanoutExchange，它比FanoutExchange更加灵活。这种灵活性也是有代价的，不要忘了在消息中加上bindingkey。



这里我们不再使用Bean的方式来声明，毕竟需要声明这么多东西。

![image-20220512114502566](黑马微服务课程笔记.assets/image-20220512114502566.png)

接下来就是基于@RabbitListener注解来声明这些组件。

之前我们写的所有消费者当中都有这个注解。但是这个注解上可以同时完成队列和交换机的声明。不用再创建Bean了。

（消费者实际上才是在代码中指定组件逻辑的，发布者只需要知道往哪个交换机or队列中发送消息就ok了）

![image-20220512114949567](黑马微服务课程笔记.assets/image-20220512114949567.png)

这里我们原来在主键中写的是queues=...

而这里我们是写bindings=@QueueBinding(...)

![image-20220512115154823](黑马微服务课程笔记.assets/image-20220512115154823.png)

这样我们就完成了绑定的声明了，并且还声明了bindingkeys。

![image-20220512115330245](黑马微服务课程笔记.assets/image-20220512115330245.png)

同样的代码copy一份来声明queue2到交换机的绑定。key为red,yellow

这里多了一个exchange叫做itcast.direct，然后进去看到queue1绑定了什么，queue2绑定了什么key。

![image-20220512115449568](黑马微服务课程笔记.assets/image-20220512115449568.png)

接着是消息发送的方法。

![image-20220512115730126](黑马微服务课程笔记.assets/image-20220512115730126.png)

这下就blue就收到了。

![image-20220512115742285](黑马微服务课程笔记.assets/image-20220512115742285.png)



### 发布订阅-TopicExchange

![image-20220512115937546](黑马微服务课程笔记.assets/image-20220512115937546.png)

这个模式和DirectExchange很像，但是routingkey必须是多个单词的列表，并且用.分割

![image-20220512120028961](黑马微服务课程笔记.assets/image-20220512120028961.png)

左下角我们看到这个routingkey的逻辑实际上和话题的非常像

那么我们去订阅的话，比如我想关系下新闻，中国的，日本的，那么我们得绑定两个key（在Direct中）。

而在TopicExchange中我们支持通配符

![image-20220512120316353](黑马微服务课程笔记.assets/image-20220512120316353.png)

![image-20220512120332408](黑马微服务课程笔记.assets/image-20220512120332408.png)

于是我们只要写china.#就可以收到所有的中国相关的话题。而我们写#.news就可以收到所有和新闻相关的话题。

这个实际上就是简化了bindingkey的写法，原来用多个key的，现在只需要用一个key就可以了。

![image-20220512120538898](黑马微服务课程笔记.assets/image-20220512120538898.png)

这下就写完成了

![image-20220512120637890](黑马微服务课程笔记.assets/image-20220512120637890.png)

itcast.exchange

![image-20220512120742956](黑马微服务课程笔记.assets/image-20220512120742956.png)

这里我们就可以测试这里的服务了。

![image-20220512120859547](黑马微服务课程笔记.assets/image-20220512120859547.png)

这个变化也没有很大

总结：

这个bindingkey可以支持通配符。然后routingkey需要用.来分割单词列表。



## 消息转换器

我们在使用rabbitTemplate的时候消息这边接收的类一直是Object，这个说明我们可以发送任意的对象。

先在config里面声明一个队列

![image-20220512121305170](黑马微服务课程笔记.assets/image-20220512121305170.png)

然后我们测试发送一个对象

```java
@Test
    public void testSendObjectQueue(){
        Map<String,Object> msg=new HashMap<>();
        msg.put("name","pixel-revolve");
        msg.put("age",20);

        rabbitTemplate.convertAndSend("object.queue",msg);

    }
```

去到rabbitmq里面，我们看到消息，还有消息类型是java序列化类型。

![image-20220512121758594](黑马微服务课程笔记.assets/image-20220512121758594.png)

它只支持字节。这种原生的序列化方式并不是那么好，性能差，安全性有问题，数据长度太长了，消息体越大，传输的效率也就越慢，而且还占用额外的内存空间。所以我们非常不推荐这种方式。



Spring的消息对象处理使用MessageConverter来处理的。

![image-20220512122120971](黑马微服务课程笔记.assets/image-20220512122120971.png)

我们使用jackson的方式来实现是比较喜欢的。



同样的我们在consumer中引入jackson的依赖，并且定义一样的MessageConverter

![image-20220512122621498](黑马微服务课程笔记.assets/image-20220512122621498.png)

这里我们就接收到了，这个方式就是比较方便的

![image-20220512122543082](黑马微服务课程笔记.assets/image-20220512122543082.png)



总结：

![image-20220512122722144](黑马微服务课程笔记.assets/image-20220512122722144.png)





# 微服务保护

## 初识Sentinel

### 雪崩问题

#### 什么是雪崩问题

微服务之间互相调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。



![image-20220831193107550](黑马微服务课程笔记.assets/image-20220831193107550.png)

#### 解决雪崩问题

解决雪崩问题的常见方式有四种：

- 超时处理：设定超时时间，请求超过一定时间美誉相应就返回错误信息，不会无休止等待。

- 舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫**线程隔离**。

- 熔断降级：由**断路器**统计业务执行的一场比例，如果超出阈值则会**熔断**该业务，拦截访问该业务的一切请求。

- 流量控制：限制业务访问的QPS（每秒钟处理请求的数量）。避免服务因流量的徒增而故障。

  ![image-20220831194047046](黑马微服务课程笔记.assets/image-20220831194047046.png)

> 流量控制是预防雪崩，前面三种是已经出现问题了。



### 服务保护技术对比

![image-20220831195551526](黑马微服务课程笔记.assets/image-20220831195551526.png)

> Hystrix现在不维护了



Sentinel是alibaba开源的一款微服务流量控制组件。



Sentinel具有以下特征：

![image-20220831200039551](黑马微服务课程笔记.assets/image-20220831200039551.png)



### 安装Sentinel控制台

去下载最新的jar包。

https://github.com/alibaba/Sentinel

![image-20220831201309612](黑马微服务课程笔记.assets/image-20220831201309612.png)

执行命令：

```bash
java -jar sentinel-dashboard-1.8.5.jar
```

然后访问：localhost:8080 即可看到控制台界面，默认账户密码都是sentinel。

![image-20220831201507442](黑马微服务课程笔记.assets/image-20220831201507442.png)



如果要修改Sentinel的默认端口，账户，密码 可以通过下列配置：

![image-20220831201625154](黑马微服务课程笔记.assets/image-20220831201625154.png)

举例：

```bash
java -jar sentinel-dashboard-1.8.5.jar -Dserver.port=8090
```

### 整合Sentinel和微服务

> 引入cloud-demo，项目结构如下：

![image-20220913124023376](黑马微服务课程笔记.assets/image-20220913124023376.png)

> 微服务整合Sentinel

我们在order-service中整合Sentinel，并且链接Sentinel的控制台，步骤如下：

1. 引入sentinel依赖：

   ```xml
   <dependency>
   	<groupId>com.alibaba.cloud</groupId>
   	<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
   </dependency>
   ```



2. 配置控制台地址：

   ```yaml
   spring:
     cloud:
       sentinel:
         transport:
           dashboard: localhost:8080
   ```

3. 访问微服务的任意端点（endpoint，我们Spring MVC的任意一个Controller的接口都是一个端点），触发sentinel监控



访问过一次接口之后再看我们的控制台，就出现结果了。

![image-20220913125146196](黑马微服务课程笔记.assets/image-20220913125146196.png)

## 限流规则

> 首先我们需要知道一个概念：



> **簇点链路**

簇点链路:就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控Spring MVC的每一个端点(Endpoint) ，因此Spring MVC的每一 个端 点(Endpoint)就是调用链路中的一个资源。



流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则:

![image-20220913125604325](黑马微服务课程笔记.assets/image-20220913125604325.png)





如果我们点击资源/order/{orderId}后面的流控按钮，就可以弹出表单。表单中可以添加流控规则。

![image-20220913125738241](黑马微服务课程笔记.assets/image-20220913125738241.png)

其含义是限制/order/{orderId}这个资源的单机QPS为1，即每秒值允许1次请求，超出的请求会被拦截并报错。



- > 案例
  >
  > 需求:给/order/{orderld}这个资源设置流控规则，QPS不能超过5。然后利用jemeter测试。

  ![image-20220913125936782](黑马微服务课程笔记.assets/image-20220913125936782.png)

  创建完成规则后我们使用Jemeter进行测试

  ![image-20220913130206387](黑马微服务课程笔记.assets/image-20220913130206387.png)

  接着看结果，限流的控制生效了！

  ![image-20220913130113975](黑马微服务课程笔记.assets/image-20220913130113975.png)

  ![image-20220913130122352](黑马微服务课程笔记.assets/image-20220913130122352.png)





### 流控模式



在添加限流规则时，点击高级选项，可以选择三种流控模式:

- 直接:统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式
- 关联:统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流
- 链路:统计从指定链路访问到本资源的请求,触发阈值时,对指定链路限流

![image-20220913130312814](黑马微服务课程笔记.assets/image-20220913130312814.png)



- > 流控模式 - 关联

  - 关联模式:统计与当前资源相关的另一个资源，触发阈值时,对当前资源限流
  - 使用场景:比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。
    业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时,需要对查询订单业务限流。

  

  ![image-20220913130533784](黑马微服务课程笔记.assets/image-20220913130533784.png)

  当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。

  - > 案例
    >
    > 需求:
    >
    > - 在OrderController新建 两个端点/order/query和/order/update, 无需实现业务
    > - 配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/ query请求限流

     ![image-20220913130848482](黑马微服务课程笔记.assets/image-20220913130848482.png)

    我们对用Jemeter对/order/update进行QPS大于5的请求，查看结果：

    ![image-20220913130923292](黑马微服务课程笔记.assets/image-20220913130923292.png)

  - > 什么时候使用关联模式？

    - 两个有竞争关系的资源
    - 一个优先级高，一个优先级低





- > 流控模式 - 链路

  链路模式:只针对从指定链路访问到本资源的请求做统计,判断是否超过阈值。
  例如有两条请求链路:

  - /test1→/common
  - /test2 →/common

  如果只希望统计从/test2进入到/common的请求，则可以这样配置:

  ![image-20220913131332366](黑马微服务课程笔记.assets/image-20220913131332366.png)

  - > 案例
    >
    > 需求:有查询订单和创建订单业务,两者都需要查询商品。针对从查询订单进入到查询商品的请求统计,并设置限流。

    1. 在OrderService中添加一个queryGoods方法,不用实现业务
    2. 在OrderController中 ，改造/order/query端点，调用OrderService中的queryGoods方法
    3. 在OrderController中 添加一个/order/save的端 点，调用OrderService的queryGoods方法
    4. 给queryGoods设 置限流规则，从/order/query进 入queryGoods的方法限制QPS必须小于2

    设定规则

    ![image-20220913140417661](黑马微服务课程笔记.assets/image-20220913140417661.png)

    用Jemeter请求，我们的save不受任何影响。

  - > Sentinel默认只标记Controller中的方法为资源，如果要标记其他方法，需要利用@SentinelResource注解

    ```java
    @SentinelResource("goods")
    public void queryGoods(){
    	System.err.println("查询商品");
    }
    ```

    Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效，需要修改application.yml，添加配置：

    ```yaml
    spring:
      cloud:
        sentinel:
          web-context-unify: false # 关闭context整合
    ```

    这样之后即便是Service层也可以被监控了。






### 流控效果

流控效果是指请求达到流控阈值时应该采取的措施，包括三种:

- 快速失败: 达到阈值后,新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
- warm up:预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化,从一个较小值逐渐增
  加到最大阈值。
- 排队等待:让所有的请求按照先后次序排队执行,两个请求的间隔不能小于指定时长

![image-20220913151326814](黑马微服务课程笔记.assets/image-20220913151326814.png)





- > 流控效果 - warm up
  >
  > 在服务刚启动的时候不能就把QPS给打满了

  warm up也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是threshold / coldFactor,持续指定时长后,逐渐提高到threshold值。而coldFactor的默认值是3.

  例如，我设置QPS的threshold为10，预热时间为5秒,那么初始阈值就是10/3,也就是3,然后在5秒后逐渐增长到10.

  ![image-20220913151601401](黑马微服务课程笔记.assets/image-20220913151601401.png)

  - > 案例
    >
    > 需求:给/order/{orderld}这个资源设置限流，最大QPS为10, 利用warm up效果,预热时长为5秒

    ![image-20220913151650293](黑马微服务课程笔记.assets/image-20220913151650293.png)

    QPS是波动变化的

    ![image-20220913151708766](黑马微服务课程笔记.assets/image-20220913151708766.png)

    ![image-20220913151724359](黑马微服务课程笔记.assets/image-20220913151724359.png)







- > 流控效果 - 排队等待

  当请求超过QPS阈值时，快速失败和warm up会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入- -个队列中,然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长,则会被拒绝。
  例如: QPS=5,意味着每200ms处理一个队列中的请求; timeout = 2000,意味着预期等待超过2000ms的请求会被拒绝并抛出异常

  ![image-20220913151917628](黑马微服务课程笔记.assets/image-20220913151917628.png)

  ![image-20220913151943807](黑马微服务课程笔记.assets/image-20220913151943807.png)

  - > 案例
    >
    > 流控效果 - 排队等待
    >
    > 需求:给/order/{orderld}这 个资源设置限流，最大QPS为10,利用排队的流控效果，超时时长设置为5s

    ![image-20220913152048294](黑马微服务课程笔记.assets/image-20220913152048294.png)

    ![image-20220913152437202](黑马微服务课程笔记.assets/image-20220913152437202.png)

    我们的发送QPS是15，然后多出来的都进入到队列里面去了。

    ![image-20220913152453176](黑马微服务课程笔记.assets/image-20220913152453176.png)

    最终呈现出来的是非常平稳的QPS，形成了对微服务的保护。

  



### 热点参数限流

> 前面的都是常见的，这个是特殊的。

之前的限流是统计访问某个资源的所有请求,判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求,判断是否超过QPS阈值。

![image-20220913153110310](黑马微服务课程笔记.assets/image-20220913153110310.png)





- > 配置示例：

  ![image-20220913153130409](黑马微服务课程笔记.assets/image-20220913153130409.png)

  代表的含义是:对hot这个资源的0号参数(第一个参数)做统计,每1秒相同参数值的请求数不能超过5





> 商品是有热点商品的，所以限流阈值不应该是一样的

在热点参数限流的高级选项中，可以对部分参数设置例外配置：

![image-20220913153349541](黑马微服务课程笔记.assets/image-20220913153349541.png)



结合上一个配置,这里的含义是对0号的long类型参数限流,每1秒相同参数的QPS不能超过5,有两个例外:

- 如果参数值是100,则每1秒允许的QPS为10
- 如果参数值是101,则每1秒允许的QPS为15



- > 案例
  >
  > 给/order/{orderld}这个资源添加热点参数限流，规则如下:
  >
  > - 默认的热点参数规则是每1秒请求量不超过2
  > - 给102这 个参数设置例外:每1秒请求量不超过4
  > - 给103这个参数设置例外:每1秒请求量不超过10

  > 注意：
  >
  > 热点参数限流对默认的SpringMVC资源无效

  我们将它覆盖成Sentinel资源

  ![image-20220913153612818](黑马微服务课程笔记.assets/image-20220913153612818.png)

  

  ![image-20220913153704090](黑马微服务课程笔记.assets/image-20220913153704090.png)

  ![image-20220913153753470](黑马微服务课程笔记.assets/image-20220913153753470.png)

  添加完规则，进行Jemeter测试

  ![image-20220913153846851](黑马微服务课程笔记.assets/image-20220913153846851.png)

  ==不同的参数，限流的上限是不一样的。热点参数限流是一种更细粒度的限流==





## 隔离和降级

> ![image-20220923131555481](黑马微服务课程笔记.assets/image-20220923131555481.png)





虽然限流可以尽量避免因高并发而引起的服务故障,但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩,就要靠线程隔离(舱壁模式)和熔断降级手段了。



线程隔离：

![image-20220913154252397](黑马微服务课程笔记.assets/image-20220913154252397.png)







熔断：

![image-20220913154235612](黑马微服务课程笔记.assets/image-20220913154235612.png)





### Feign整合Sentinel



> 不管是线程隔离还是熔断降级，都是对客户端（调用方）的保护
>
> 而调用方是Feign，于是实际上是对Feign的保护。



- > Feign整合Sentinel

  SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端必须整合Feign和Sentinel

  首先的准备：

  1. 修改OrderService的application.yml文件，**开启Feign的Sentinel功能**
  
     ```yaml
     feign:
       sentinel:
         enable: true # 开启Feign的Sentinel功能
     ```

  2. 给FeignClient编写失败后的降级逻辑
  
     - 方式一：FallbackClass，无法对远程调用的异常做处理
     - 方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种
  
  
  
  
  步骤一：在feign-api项目中定义类，**实现FallbackFactory:**
  
  ![image-20220923130625293](黑马微服务课程笔记.assets/image-20220923130625293.png)
  
  > create方法返回的就是UserClient对象，实现方法的过程中就是在编写备用的方案。记录日志，返回友好提示啊之类的。这个就是一个失败降级的业务逻辑了。
  
  
  
  步骤二:在feing- api项目中的DefaultFeignConfiguration类中**将UserClientFallbackFactory注册为一个Bean:**
  
  ![image-20220923130939462](黑马微服务课程笔记.assets/image-20220923130939462.png)
  
  
  
  步骤三:在feing-api项目中的UserClient接口中**使用UserClientFallbackFactory:**
  
  ![image-20220923130958536](黑马微服务课程笔记.assets/image-20220923130958536.png)
  
  
  
  最后我们访问一下接口，这下链路就出来了。其中出现了Feign的请求接口，这下，我们就完成了Feign和Sentinel的整合了。
  
  ![image-20220923131431070](黑马微服务课程笔记.assets/image-20220923131431070.png)

###   线程隔离

> ![image-20220923143632484](黑马微服务课程笔记.assets/image-20220923143632484.png)





> 线程隔离有两种方式实现:

- **线程池隔离**

  - > 优点

    - 支持主动超时
    - 支持异步调用

  - > 缺点

    - 线程的额外开销比较大

  - > 场景

    - 低扇出

-  **信号量隔离**(Sentinel默认采用)

  - > 优点

    - 轻量级，无额外开销

  - > 缺点

    - 不支持主动超时
    - 不支持异步调用

  - > 场景

    - 高频调用
    - 高扇出（网关就是这样的场景）



- > 线程池隔离（左），信号量隔离（右）

![image-20220923131759662](黑马微服务课程笔记.assets/image-20220923131759662.png)





- > Sentinel如何实现线程隔离？

  在添加限流规则时，可以选择两种阈值类型:

  ![image-20220923143225183](黑马微服务课程笔记.assets/image-20220923143225183.png)

  - QPS: 就是每秒的请求数，在快速入门中已经演示过。
  - 线程数：是改资源能够使用的tomcat线程数的最大值。也就是通过限制线程数量，实现**舱壁模式**。

  

- > 案例：
  >
  > 需求:给UserClient的查询用户接口设置流控规则，线程数不能超过2。然后利用jemeter测试。

  ![image-20220923143420099](黑马微服务课程笔记.assets/image-20220923143420099.png)

  ![image-20220923143441768](黑马微服务课程笔记.assets/image-20220923143441768.png)

  ![image-20220923143506668](黑马微服务课程笔记.assets/image-20220923143506668.png)

  前面的请求实际上都是正常的，后面多于2的请求就降级了。这个就实现了信号量的隔离。





### 熔断降级

> ![image-20220923145146063](黑马微服务课程笔记.assets/image-20220923145146063.png)



熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求;而当服务恢复时，断路器会放行访问该服务的请求。



> 它是使用状态机来实现的。





> Sentinel里面断路器的3个状态，以及切换的流程和作用

![image-20220923143806040](黑马微服务课程笔记.assets/image-20220923143806040.png)





> **熔断策略-慢调用**

断路器熔断策略有三种:慢调用、异常比例、异常数

- 慢调用:**业务的响应时长(RT)大于指定时长的请求认定为慢调用请求**。在指定时间内，如果请求数量超过设定的
  最小数量，慢调用比例大于设定的阈值，则触发熔断。例如:

  ![image-20220923144006088](黑马微服务课程笔记.assets/image-20220923144006088.png)

  > 解读: RT超过500ms的调用是慢调用，统计最近10000ms内的请求,如果请求量超过10次，并且慢调用比例不低于0.5
  > 则触发熔断，熔断时长为5秒。然后进入half-open状态,放行一次请求做测试。

- > 案例：
  >
  > 需求:给UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms,统计时间为1秒,最小请求数量为5,失败阈值比例为0.4,熔断时长为5
  > 提示:为了触发慢调用规则，我们需要修改UserService中的业务,增加业务耗时: 

  ![image-20220923144208687](黑马微服务课程笔记.assets/image-20220923144208687.png)

  ![image-20220923144505707](黑马微服务课程笔记.assets/image-20220923144505707.png)

  我们先刷5次/order/1，然后再看/order/2

  ![image-20220923144614238](黑马微服务课程笔记.assets/image-20220923144614238.png)

  发现已经熔断了。这个就是慢比例熔断了。





> 熔断策略-异常比例、异常数

断路器熔断策略有三种:慢调用、异常比例或异常数

- 异常比例或异常数:统计指定时间内的调用，如果调用次数超过指定请求数,并且出现异常的比例达到设定的比例阈
  值(或超过指定异常数) ,则触发熔断。例如:

  ![image-20220923144723285](黑马微服务课程笔记.assets/image-20220923144723285.png)![image-20220923144759941](黑马微服务课程笔记.assets/image-20220923144759941.png)

  > 解读:统计最近1000ms内的请求,如果请求量超过10次,并且异常比例不低于0.5,则触发熔断,熔断时长为5秒。然后进入half-open状态，放行一-次请 求做测试。

- > 案例：
  >
  > 需求:给UserClient的查询用户接口设置降级规则，统计时间为1秒,最小请求数量为5,失败阈值比例为0.4,熔断时长为5s
  >
  > 提示:为了触发异常统计,我们需要修改UserService中的业务,抛出异常:

  ![image-20220923144839350](黑马微服务课程笔记.assets/image-20220923144839350.png)

  ![image-20220923145006379](黑马微服务课程笔记.assets/image-20220923145006379.png)

  我们刷了5次异常的102，再访问103。出发了异常比例降级。

  ![image-20220923145107080](黑马微服务课程笔记.assets/image-20220923145107080.png)



### 授权规则

> 对请求者身份的判断



授权规则可以对**调用方的来源做控制**，有白名单和黑名单两种方式。

- 白名单:来源(origin)在白名单内的调用者允许访问

- 黑名单:来源(origin) 在黑名单内的调用者不允许访问

![image-20220923145322780](黑马微服务课程笔记.assets/image-20220923145322780.png)



例如，我们只限定允许从网关来的请求访问order-service，那么流控应用中就填写网关的名称

![image-20220923145435568](黑马微服务课程笔记.assets/image-20220923145435568.png)



Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。

![image-20220923145546980](黑马微服务课程笔记.assets/image-20220923145546980.png)

我们需要自己编写这个业务逻辑。



例如，我们尝试从request中获取一个名为origin的请娘娘球头，作为origin的值：

![image-20220923145655313](黑马微服务课程笔记.assets/image-20220923145655313.png)



我们还需要在gateway服务中，利用网关的过滤器添加名为gateway的origin头：

![image-20220923145747672](黑马微服务课程笔记.assets/image-20220923145747672.png)



给/order/{orderId}配置授权规则：

![image-20220923145813126](黑马微服务课程笔记.assets/image-20220923145813126.png)





### 自定义异常结果

> ![image-20220923150742983](黑马微服务课程笔记.assets/image-20220923150742983.png)



默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：

![image-20220923150157974](黑马微服务课程笔记.assets/image-20220923150157974.png)



而BlockException包含很多个子类，分别对应不同的场景:

![image-20220923150254983](黑马微服务课程笔记.assets/image-20220923150254983.png)



我们在order-service中定义类，实现BlockExceptionHandler接口：

![image-20220923150325418](黑马微服务课程笔记.assets/image-20220923150325418.png)





测试：

![image-20220923150650180](黑马微服务课程笔记.assets/image-20220923150650180.png)

可以看到被限流了：

![image-20220923150657913](黑马微服务课程笔记.assets/image-20220923150657913.png)



### 规则持久化

> ![image-20220923152156519](黑马微服务课程笔记.assets/image-20220923152156519.png)



> 这章学习如何让Sentinel的规则持久化



Sentinel的控制台规则管理有三种模式：

- 原始模式（不支持持久化）

  Sentinel的默认模式，将规则保存在内存，重启服务会丢失

- pull模式(存在处理一致性问题)

  pull模式:控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。

  ![image-20220923151012266](黑马微服务课程笔记.assets/image-20220923151012266.png)

- push模式（我们最推荐的）

  push模式:控制台将配置规则推送到远程配置中心，例如Nacos。 Sentinel客 户端监听Nacos,获取配置变更的推送消息，完成本地配置更新。

  ![image-20220923151130897](黑马微服务课程笔记.assets/image-20220923151130897.png)

  

  > 实现push模式

  push模式实现最为复杂，依赖于nacos, 并且需要修改Sentinel控制台源码。

  ![image-20220923152333777](黑马微服务课程笔记.assets/image-20220923152333777.png)

  我们需要修改OrderService，让其监听Nacos中的sentinel规则配置。

  

  具体步骤如下：

  - 一、修改order-service服务

    1. 引入依赖

       在order-service中引入sentinel监听nacos的依赖：

       ![image-20220923152535486](黑马微服务课程笔记.assets/image-20220923152535486.png)

    

    2. 配置nacos地址

       在order-service中的application.yml文件配置nacos地址及监听的配置信息:

       ![image-20220923152605140](黑马微服务课程笔记.assets/image-20220923152605140.png)

       

  - 二、修改sentinel-dashboard源码

    SentinelDashboard默认不支持nacos的持久化，需要修改源码

    

    1. 解压并打开项目

       ![image-20220923152912167](黑马微服务课程笔记.assets/image-20220923152912167.png)

       

    2. 修改nacos依赖

       在sentinel-dashboard源码的pom文件中，nacos的依赖默认的scope是test，只能在测试时使用，这里要去除： 

       ![image-20220923153014419](黑马微服务课程笔记.assets/image-20220923153014419.png)

       将sentinel-datasource-nacos依赖的scope去掉：

       ![image-20220923153100997](黑马微服务课程笔记.assets/image-20220923153100997.png)

       

    3. 添加nacos支持

       在sentinel-dashboard的test包下，已经编写了对nacos的支持，我们需要将其拷贝到main下。

       ![image-20220923153422725](黑马微服务课程笔记.assets/image-20220923153422725.png)

       

    4. 修改nacos地址

       然后，还需要修改测试代码中的NacosConfig类：

       ![image-20220923154138371](黑马微服务课程笔记.assets/image-20220923154138371.png)

       修改其中的nacos地址，让其读取application.properties中的配置：

       ![image-20220923154229866](黑马微服务课程笔记.assets/image-20220923154229866.png)

       在sentinel-dashboard的application.properties中添加nacos地址配置：

       ```yaml
       nacos.addr=localhost:8848
       ```

    5. 配置nacos数据源

       另外，还需要修改com.alibaba.csp.sentinel.dashboard.controller.v2包下的FlowControllerV2类。

       ![image-20220923154420808](黑马微服务课程笔记.assets/image-20220923154420808.png)

       让我们添加的Nacos数据源生效：

       ![image-20220923154443390](黑马微服务课程笔记.assets/image-20220923154443390.png)

    6. 修改前端页面

       接下来，还需要修改前端页面，添加一个支持nacos的菜单

       修改src/amin/webapp/resources/app/scripts/directives/sidebar/目录下的sidebar.html文件：

       ![image-20220923154504714](黑马微服务课程笔记.assets/image-20220923154504714.png)

       将其中的这部分注释打开：

       ![image-20220923154650957](黑马微服务课程笔记.assets/image-20220923154650957.png)

       修改其中的文本： 

       ![image-20220923154705033](黑马微服务课程笔记.assets/image-20220923154705033.png)

    7. 重新编译、打包项目

       运行IDEA中的maven插件，编译和打包修改好的Sentinel-Dashboard：

       ![image-20220923155538464](黑马微服务课程笔记.assets/image-20220923155538464.png)

       

       在sentinel中新增限流规则：

       ![image-20220923160353152](黑马微服务课程笔记.assets/image-20220923160353152.png)

      在nacos中寻找一下：

    ![image-20220923160142097](黑马微服务课程笔记.assets/image-20220923160142097.png)

    重启发现已经实现了持久化。

    

# 分布式事务

> 事务的ACID原则

![image-20220923160711366](黑马微服务课程笔记.assets/image-20220923160711366.png)





> 分布式服务案例

微服务下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务:

- 账户服务负责扣减用户余额
- 库存服务负责扣减商品库存

![image-20220923160743108](黑马微服务课程笔记.assets/image-20220923160743108.png)



>  演示分布式事务问题

![image-20220923160816891](黑马微服务课程笔记.assets/image-20220923160816891.png)

这里测试下单如果都成功了对应的三张表中的内容应该都得到了修改：

![image-20220923161104920](黑马微服务课程笔记.assets/image-20220923161104920.png)



如果下单失败了呢？

![image-20220923161237475](黑马微服务课程笔记.assets/image-20220923161237475.png)

事务的状态是不一致的。



> 什么是分布式事务问题

在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务,要保证所有分支事务最终状态一致,这样的事务就是分布式事务。

![image-20220923161308496](黑马微服务课程笔记.assets/image-20220923161308496.png)
